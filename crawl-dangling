#!/usr/bin/env python3
from argparse import ArgumentParser
import os
from pathlib import Path
import sys
from typing import Optional

import logging
from kython.klogging import setup_logzero

def get_logger():
    return logging.getLogger('crawl-dangling')

BACKED_UP = {
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
    '***REMOVED***',
}


def matches_prefix(path: Path, prefixes) -> bool:
    for b in prefixes:
        try:
            path.relative_to(Path(b))
            return True
        except ValueError:
            continue
    else:
        return False


def is_backed_up(path: Path) -> bool:
    return matches_prefix(path=path, prefixes=BACKED_UP)


def excluded(p: Path) -> bool:
    if p.stem in ('.check-symlinks', '.mypy_cache'):
        return True
    if (p / '.nodangling').exists():
        return True
    return False


def main():
    logger = get_logger()
    setup_logzero(logger, level=logging.DEBUG)

    p = ArgumentParser()
    p.add_argument('--skip', action='append')
    p.add_argument('roots', nargs='*', default=['***REMOVED***'])
    args = p.parse_args()

    skipped = [] if args.skip is None else args.skip

    errors = []
    def error(*args):
        logger.error(*args)
        errors.append(args)

    def is_handled(p: Path) -> bool:
        if is_backed_up(p):
            return True
        if matches_prefix(p, prefixes=skipped):
            return True
        if excluded(p):
            return True
        return False

    # TODO hmm. reuse kythong thing?
    dirs = [Path(p) for p in args.roots]
    for dd in dirs:
        logger.info('checking %s', dd)
        if not dd.exists():
            error("%s doesn't exist!", dd)
            continue
        for root, dirs, files in os.walk(dd, topdown=True):
            r = Path(root)
            logger.debug('checking %s', r)
            if is_handled(r):
                logger.info('skipping %s', r)
                dirs[:] = []
                files[:] = []
            for f in files:
                mf: Optional[Path] = None
                ff = r.joinpath(f)
                if mf is not None and not excluded(mf):
                    error(mf)

    if len(errors) > 0:
        sys.exit(1)

if __name__ == '__main__':
    main()
